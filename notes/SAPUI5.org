#+STARTUP: inlineimages
* QUESTIONS
  A list a questions I gathered while going through SAPUI5 tutorial
  
  *Q:* 
  Do nested views inherit the parent controller if a controller 
  is not explicitly defined via controllerName property of the 
  child view? What about models?
  
  e.g 
  If an eventHandler of the child view is defined in the parent, will
  the triggered event be resolved in the parent controller?

  - Answer :: No, as stated in the docs views and controllers form 1:1 
              relationship

  e.g
  If a model is defined in the parent view's controller,
  will the child view be able to access the model?

  - Answer :: Yes, if the model is defined in the parent controller,
              the child will be able to access the model EVEN IF
              the child explicitly defined its own controller. 
              Note:
              - If the model is defined in the child controller,
                the parent cannot access that model.
              - If model is defined in the component/manifest,
                the model is available anywhere (since model
                will be instantiated into the RootView?)
  
* XML Views
  *convetions*
  - View names are capitalized
  - All views are stored in the view folder
  - Names of XML views always end with *.view.xml
  - The default XML namespace is sap.m
  - Other XML namespaces use the last part of the SAP 
    namespace as alias (for example, mvc for sap.ui.core.mvc

  webapp/view/App.view.xml
  #+BEGIN_SRC xml
    <mvc:View
       xmlns="sap.m"
       xmlns:mvc="sap.ui.core.mvc">
       <Text text="Hello World"/>
    </mvc:View>
  #+END_SRC
  The XML tags are mapped to controls, and the attributes are mapped
  to the properties of the controls

  webapp/index.html
  #+BEGIN_SRC html
    <!DOCTYPE html>
    <html>
       <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge">
          <meta charset="utf-8">
          <title>Walkthrough</title>
          <script
             id="sap-ui-bootstrap"
             src="/resources/sap-ui-core.js"
             data-sap-ui-theme="sap_belize"
             data-sap-ui-libs="sap.m"
             data-sap-ui-compatVersion="edge"
             data-sap-ui-preload="async"
             data-sap-ui-resourceroots='{
                "sap.ui.demo.wt": "./"
             }' >
          </script>
          <script>
             sap.ui.getCore().attachInit(function () {
                sap.ui.xmlview({
                   viewName : "sap.ui.demo.wt.view.App"
                }).placeAt("content");
             });
          </script>
       </head>
       <body class="sapUiBody" id="content">
       </body>
    </html>  
  #+END_SRC

* Controllers
  *conventions*
  - Controller names are capitalized
  - Controllers carry the same name as the related view 
    (if there is a 1:1 relationship)
  - Event handlers are prefixed with on
  - Controller names always end with *.controller.js


  
  webapp/view/App.view.xml
  #+BEGIN_SRC xml
    <mvc:View
       controllerName="sap.ui.demo.wt.controller.App"
       xmlns="sap.m"
       xmlns:mvc="sap.ui.core.mvc">
       <Button
          text="Say Hello"
          press="onShowHello"/>
    </mvc:View>
  #+END_SRC
  We specify name of the controller conencted to the view via 'controllerName'.
  A view however, doesn't need an explictly assigned controller. If a controller
  is specified, it is *instantiated after the view is loaded*.

  webapp/controller/App.controller.js
  #+BEGIN_SRC javascript
    sap.ui.define([
       "sap/ui/core/mvc/Controller"
    ], function (Controller) {
       "use strict";
       return Controller.extend("sap.ui.demo.wt.controller.App", {
          onShowHello : function () {
             // show a native JavaScript alert
             alert("Hello World");
          }
       });
    });
  #+END_SRC
  
* Modules
  *conventions*
  - Use *sap.ui.define* for controllers and all other JavaScript modules 
    to define a global namespace. With the namespace, the object can 
    be addressed throughout the application.
  - Use *sap.ui.require* for asynchronously loading dependencies but 
    without declaring a namespace, for example code that just needs to
    be executed, but does not need to be called from other code.
  - Use the name of the artifact to load for naming the function 
    parameters (without namespace).
  - In SAPUI5 resources are often referred to as modules.
  
  /webapp/controller/App.controller.js
  #+BEGIN_SRC javascript
    sap.ui.define([
       "sap/ui/core/mvc/Controller",
       "sap/m/MessageToast"
    ], function (Controller, MessageToast) {
       "use strict";
       return Controller.extend("sap.ui.demo.wt.controller.App", {
          onShowHello : function () {
             MessageToast.show("Hello World");
          }
       });
    });
  #+END_SRC
  Extend the array of required modules with the fully qualified path to 
  sap.m.MessageToast.
  Once both modules are loaded, the callback function is called and we can
  make use of both objects by accessing parameters passed on to the function.

  *NOTE* 
  The order of modules defined is the order of paramters in the callback
  function!

* JSON Model
  *conventions*
  - Use Hungarian notation for variable names
    i.e oData, oModel
  
  webapp/controller/App.controller.js
  #+BEGIN_SRC javascript
    sap.ui.define([
       "sap/ui/core/mvc/Controller",
       "sap/m/MessageToast",
       "sap/ui/model/json/JSONModel"
    ], function (Controller, MessageToast, JSONModel) {
       "use strict";
       return Controller.extend("sap.ui.demo.wt.controller.App", {
          onInit : function () {
             // set data model on view
             var oData = {
                recipient : {
                   name : "World"
                }
             };
             var oModel = new JSONModel(oData);
             this.getView().setModel(oModel);
          },
          onShowHello : function () {
             MessageToast.show("Hello World");
          }
       });
    });
  #+END_SRC

  To use the model from within the XML view, we call the setModel function on 
  the view and pass on newly created model

  webapp/view/App.view.xml
  #+BEGIN_SRC xml
    <mvc:View
       controllerName="sap.ui.demo.wt.controller.App"
       xmlns="sap.m"
       xmlns:mvc="sap.ui.core.mvc">
       <Button
          text="Say Hello"
          press="onShowHello"/>
       <Input
          value="{/recipient/name}"
          description="Hello {/recipient/name}"
          valueLiveUpdate="true"
          width="60%"/>
    </mvc:View>  
  #+END_SRC
  
  curly brackets {...} indicate data is taken from value of the recipient's
  object name property (called 'data binding')

  webapp/index.html
  #+BEGIN_SRC html
      <!DOCTYPE html>
    <html>
       ...
       <head>
             ...
             data-sap-ui-compatVersion="edge"   
             ...
       </head>
       ...
    </html>
  #+END_SRC
  To allow complex binding syntax to combine text and bingind pattern,
  one must specify data-sap-ui-compatVersion="edge".
  ex.
  To allow "Hello {/recipient/name}" instead of just "{/recipient/name}"


  *Note* 
  You can either use data-sap-ui-compatVersion="edge" or
  data-sap-ui-bindingSyntax="complex" in the script. By setting the
  “edge” compatibility mode, the complex binding syntax is
  automatically enabled. The edge mode automatically enables
  compatibility features that otherwise would have to be enabled
  manually.

* Internationalizaton (i18n)
  *conventions*
  - The resource model for internationalization is called the i18n model.
  - The default filename is i18n.properties.
  - Resource bundle keys are written in (lower) camelCase.
  - Resource bundle values can contain parameters like {0}, {1}, {2}, …
  - Never concatenate strings that are translated, always use placeholders.
  - Use Unicode escape sequences for special characters.

  A way to translate text into different languages. Once approach is 
  to store text in a central place so as to easily translate to other
  languages

  webapp/i18n/i18n.properties
  #+BEGIN_SRC 
  showHelloButtonText=Say Hello
  helloMsg=Hello {0}
  #+END_SRC
  
  One can add any number of parameters to the text using {n} (starting with 0)

  controller/App.controller.js
  #+BEGIN_SRC javascript
    sap.ui.define([
       "sap/ui/core/mvc/Controller",
       "sap/m/MessageToast",
       "sap/ui/model/json/JSONModel",
       "sap/ui/model/resource/ResourceModel"
    ], function (Controller, MessageToast, JSONModel, ResourceModel) {
       "use strict";
       return Controller.extend("sap.ui.demo.wt.controller.App", {
         onInit : function () {
             // set data model on view
             var oData = {
                recipient : {
                   name : "World"
                }
             };
             var oModel = new JSONModel(oData);
             this.getView().setModel(oModel);
         // set i18n model on view
             var i18nModel = new ResourceModel({
                bundleName: "sap.ui.demo.wt.i18n.i18n"
             });
             this.getView().setModel(i18nModel, "i18n");
          },
          onShowHello : function () {
             // read msg from i18n model
             var oBundle = this.getView().getModel("i18n").getResourceBundle();
             var sRecipient = this.getView().getModel().getProperty("/recipient/name");
             var sMsg = oBundle.getText("helloMsg", [sRecipient]);
             // show message
             MessageToast.show(sMsg);
          }
       });
    });
  #+END_SRC
  
  /webapp/view/App.view.xml
  #+BEGIN_SRC xml
     <mvc:View
       controllerName="sap.ui.demo.wt.controller.App"
       xmlns="sap.m"
       xmlns:mvc="sap.ui.core.mvc">
       <Button
          text="{i18n>showHelloButtonText}"
          press="onShowHello"/>
       <Input
          value="{/recipient/name}"
          description="Hello {/recipient/name}"
          valueLiveUpdate="true"
          width="60%"/>
    </mvc:View>
  #+END_SRC

  In the XML view, we use data binding to connect the button text to
  the showHelloButtonText property in the i18n model. A resource
  bundle is a flat structure, therefore the preceding slash (/) can be
  omitted for the path.

  *Note* 
  The description text is not completely localized in this
  example for illustration purposes. To be on the safe side, we would
  have to use a similar mechanism as in the controller to use a string
  from the resource bundle and replace parts of it. This can be done
  with the jQuery.sap.formatMessage formatter.

  Furthermore, i18n files only impact client-side application
  texts. Texts that are loaded from back-end systems can appear in all
  languages that are supported by the back-end system.
  
* Components
  - Encapsulate all UI assets in a component inpedenent of index.html file
  - Independent reusable parts used in SAPUI5
    
  webapp/Component.js
  #+BEGIN_SRC javascript
    sap.ui.define([
       "sap/ui/core/UIComponent",
       "sap/ui/model/json/JSONModel",
       "sap/ui/model/resource/ResourceModel"
    ], function (UIComponent, JSONModel, ResourceModel) {
       "use strict";
       return UIComponent.extend("sap.ui.demo.wt.Component", {
                metadata : {
            rootView: "sap.ui.demo.wt.view.App"
        },
          init : function () {
             // call the init function of the parent
             UIComponent.prototype.init.apply(this, arguments);
             // set data model
             var oData = {
                recipient : {
                   name : "World"
                }
             };
             var oModel = new JSONModel(oData);
             this.setModel(oModel);

             // set i18n model
             var i18nModel = new ResourceModel({
                bundleName : "sap.ui.demo.wt.i18n.i18n"
             });
             this.setModel(i18nModel, "i18n");
          }
       });
    });
  #+END_SRC

  The init function is automatically invoked when component is instantiated.
  Component inherits from base class 'sap.ui.core.UIComponent'.
  
  *Must make the super call to the init function of the base class in the
  overridden init method*

  The metadata section defined reference to root view so that instead of
  directly displaying root view in index.html, the component manges the display
  of the app view. 

  In init, data models are instantiated like the app controller. Beware models
  directly set in component and not on the root view of the components. However
  nested controls inherit the models from their parent controls, so the models
  will be available on the view as well!

  webapp/index.html
  #+BEGIN_SRC html
    <!DOCTYPE html>
    <html>
       <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge">
          <meta charset="utf-8">
          <Title>Walkthrough</Title>
          <Script
             Id="sap-ui-bootstrap"
             src="/resources/sap-ui-core.js"
             data-sap-ui-theme="sap_belize"
             data-sap-ui-libs="sap.m"
             data-sap-ui-bindingSyntax="complex"
             data-sap-ui-compatVersion="edge"
             data-sap-ui-preload="async"
             data-sap-ui-resourceroots='{
                "sap.ui.demo.wt": "./"
             }' >
          </script>
          <script>
             sap.ui.getCore().attachInit(function () {
                new sap.ui.core.ComponentContainer({
                   name : "sap.ui.demo.wt"
                }).placeAt("content");

             });
          </script>
       </head>
       <body class="sapUiBody" id="content">
       </body>
    </html>
  #+END_SRC

  Index page now instantiates the component instead of app view.
  sap.ui.core.ComponentContrainer instantiates the component by searching
  for a Component.js file in the namespace that is passed in as an argument.

  Component automatically loads the root view we have defined above and displays
  it. 

* Descriptor for Applications (manifest.json)
  *conventions*
  - The descriptor file is named manifest.json and located in the webapp folder.
  - Use translatable strings for the title and the description of the app.

  Application-specific configuration settings are put in manjfest.json.
  Not only clearly separates config from app, but required for app to be
  hosted in FIORI Launchpad. 

  SAP Fiori is like an application container to allow apps to be instantiated
  without having a local html for bootstrap, rather the descriptor file is parsed
  and the components are loaded into current html (SPA).

  The manifest file is called the descriptor for applications, components, AKA
  'descriptor'. It is read by SAPUI5 to instantiate the component. Three important
  sector defined by the namespaces in the manifest.json file:

  - sap.app :: application specific atttributes
    - id (mandatory): namespace of application
    - type: what we want to configure (i.e application)
    - i18n: path to resource bundle file
    - title: title in the handlebars syntax referenced from app's resource bundle
    - description: handlebar syntax referenced from app's resource bundle
    - applicationVersion: version of app to easily update later
  - sap.ui :: contributes the following UI-specific attributes:
    - technology: specify UI technology, in our case SAPUI5
    - deviceTypes: what devices are supported by the app: desktop, tablet, phone
      (all true by default)
    - supportedThemes: array of themes supported by the app
  - sap.ui5 :: SAPUI5-specific configuration parameters that are automatically
               processed by SAPUI5. The most important params are:
    - rootView: if specified, the component will automatically 
      instantiate the view and use it as the root for this component
    - dependencies: declare UI libraries used in the application
    - models: define models that will be automatically instantiated by SAPUI5 when
      app starts. In the example, we define the local resource bundle here:
      - the name of the model "i18n" is the json key and bundleName specify 
        the bundle file by namespace i.e "sap.ui.demo.wt.i18n.i18n"
  
  *manifest.json example*
   #+BEGIN_SRC javascript
     {
       "_version": "1.1.0",
       "sap.app": {
         "_version": "1.1.0",
         "id": "sap.ui.demo.wt",
         "type": "application",
         "i18n": "i18n/i18n.properties",
         "title": "{{appTitle}}",
         "description": "{{appDescription}}",
         "applicationVersion": {
           "version": "1.0.0"
         }
       },
       "sap.ui": {
         "_version": "1.1.0",
         "technology": "UI5",
         "deviceTypes": {
           "desktop": true,
           "tablet": true,
           "phone": true
         },
         "supportedThemes": [
           "sap_belize"
         ]
       },
       "sap.ui5": {
         "_version": "1.1.0",
         "rootView": "sap.ui.demo.wt.view.App",
         "dependencies": {
           "minUI5Version": "1.30",
           "libs": {
             "sap.m": {}
           }
         },
         "models": {
           "i18n": {
             "type": "sap.ui.model.resource.ResourceModel",
             "settings": {
               "bundleName": "sap.ui.demo.wt.i18n.i18n"
             }
           }
         }
       }
     }
   #+END_SRC

  webapp/Component.js
  #+BEGIN_SRC javascript
    sap.ui.define([
       "sap/ui/core/UIComponent",
       "sap/ui/model/json/JSONModel"
    ], function (UIComponent, JSONModel) {
       "use strict";
       return UIComponent.extend("sap.ui.demo.wt.Component", {
          metadata : {
                manifest: "json"
          },
          init : function () {
             // call the init function of the parent
             UIComponent.prototype.init.apply(this, arguments);
             // set data model
             var oData = {
                recipient : {
                   name : "World"
                }
             };
             var oModel = new JSONModel(oData);
             this.setModel(oModel);
          }
       });
    });
  #+END_SRC

  1) metadata.rootView property is now replaced with metadata.manifest which 
     defines a reference to the descriptor that will be loaded and parsed 
     automatically when component is instantiated. 
  2) This means we no longer need the model instantiation of the resource bundle since
     the config. entries of descriptor defined the model
  3) We remove the ResourceModel dependency since it is taken care of in descriptor
     (manifest) file.
     
  *notes* 
  In previous versions of SAPUI5, additional configuration
  settings for the app, like the service configuration, the root view,
  and the routing configuration, had to be added to the metadata
  section of the Component.js file. As of SAPUI5 version 1.30, we
  recommend that you define these settings in the manifest.json
  descriptor file. Apps and examples that were created based on an
  older SAPUI5 version still use the Component.js file for this
  purpose - so it is still supported, _but not recommended_.

* Pages and Panels (control aggregation)
  *conventions* 
  Do not make implicit use of default aggregations but
  always declare the aggregation names explicitly in the view. In the
  example below, the content aggregation could also be omitted as the
  Panel control declares it as a default, but it makes the view harder
  to read.
  
  webapp/view/App.view.xml
  #+BEGIN_SRC xml
    <mvc:View
       controllerName="sap.ui.demo.wt.controller.App"
       xmlns="sap.m"
       xmlns:mvc="sap.ui.core.mvc"
      displayBlock="true">
       <App>
          <pages>
             <Page title="{i18n>homePageTitle}">
                <content>
                   <Panel
                      headerText="{i18n>helloPanelTitle}">
                      <content>

                         <Button
                            text="{i18n>showHelloButtonText}"
                            press="onShowHello"/>
                         <Input
                            value="{/recipient/name}"
                            description="Hello {/recipient/name}"
                            valueLiveUpdate="true"
                            width="60%"/>
                      </content>
                   </Panel>
                </content>
             </Page>
          </pages>
       </App>
    </mvc:View>  
  #+End_Src

  input and button field is put inside a containing control called sap.m.Page.
  the page provides an aggregation of 0..N other controls called content. 

  sap.m.Page itself is placed into the pages aggregation of another control 
  called sap.m.App which does:
  - writes useful properties into the header of index.html necessary for proper 
    display on mobile devices
  - offers functionality to navigate between pages with animations

  'displayBlock="true"' makes the fullscreen height of view to work properly

  webapp/i18n/i18n.properties
  #+BEGIN_SRC sh
    # App Descriptor
    appTitle=Hello World
    appDescription=A simple walkthrough app that explains the most important concepts of SAPUI5

    # Hello Panel
    showHelloButtonText=Say Hello
    helloMsg=Hello {0}
    homePageTitle=Walkthrough
    helloPanelTitle=Hello World
  #+END_SRC

* Shell controls as Container
  Use of the shell control as a container used as the root element
  allows for visual adaptation to device's screens size (i.e 
  letterbox on desktop screens).

  Customizations such as setting custom background image, custom logo
  and more are available.

  webapp/index.html
  #+BEGIN_SRC html
    <!DOCTYPE html>
    <html>
       <head>
          …
          <script>
             sap.ui.getCore().attachInit(function () {
                new sap.m.Shell({
                   app : new sap.ui.core.ComponentContainer({
                      name : "sap.ui.demo.wt",
                      height : "100%"
                   })
                }).placeAt("content");
             });
          </script>
       </head>
       <body class="sapUiBody" id="content">
       </body>
    </html>
  #+END_SRC

  *note*
  We do not add the Shell control to the declarative UI definition in
  the XML view, because apps that run in an external shell, like the
  SAP Fiori launchpad, there will already be a shell around the
  component UI.
* Margins and Paddings
  *conventions*
  - Use standard SAPUI5 CSS classes for the layout when possible
  
  Before margin and padding /webapp/view/App.view.xml
  #+BEGIN_SRC xml
    <mvc:View
       controllerName="sap.ui.demo.wt.controller.App"
       xmlns="sap.m"
       xmlns:mvc="sap.ui.core.mvc"
      displayBlock="true">
       <App>
          <pages>
             <Page title="{i18n>homePageTitle}">
                <content>
                   <Panel
                      headerText="{i18n>helloPanelTitle}">
                      <content>

                         <Button
                            text="{i18n>showHelloButtonText}"
                            press="onShowHello"/>
                         <Input
                            value="{/recipient/name}"
                            description="Hello {/recipient/name}"
                            valueLiveUpdate="true"
                            width="60%"/>
                      </content>
                   </Panel>
                </content>
             </Page>
          </pages>
       </App>
    </mvc:View>
  #+END_SRC
  [[./nomp.png]]

  After margin and padding /webapp/view/App.view.xml
  #+BEGIN_SRC xml
    <mvc:View
        controllerName="sap.ui.demo.wt.controller.App"
        xmlns="sap.m"
        xmlns:mvc="sap.ui.core.mvc"
        displayBlock="true">
        <App>
            <pages>
                <Page title="{i18n>homePageTitle}">
                    <content>
                        <Panel
                            headerText="{i18n>helloPanelTitle}"
                            class="sapUiResponsiveMargin" 
                            width="auto"> <!-- new -->
                            <content>
                                <Button
                                    text="{i18n>showHelloButtonText}"
                                    press="onShowHello"
                                    class="sapUiSmallMarginEnd"/> <!-- new -->
                                <Input
                                    value="{/recipient/name}"
                                    valueLiveUpdate="true"
                                    width="60%"/>
                                <Text
                                    text="Hello {/recipient/name}"
                                    class="sapUiSmallMargin"/> <!-- new -->

                            </content>
                        </Panel>
                    </content>
                </Page>
            </pages>
        </App>
    </mvc:View>  
  #+END_SRC
  [[./mp.png]]
  
  *sapUiResponsiveMargin* adds space around the panel and auto since margin would
  otherwise be added to the default width of 100% and exceed the page size

  margins can be added to all kinds of controls. Space is added between button 
  and input field with *sapUiSmallMarginEnd*

  To format output text individually, we remove attibute of the input field and
  add a new Text control with same value. We use *sapUiSmallMargin* to align
  it with other contents.

  One could also add the standard padding classes to layout the inner parts
  of the panel but since it brings padding by default, not necessary.

p* Custom CSS and Theme Colors
  *convention*
  - Do not specify colors in custom CSS but use standard theme-dependent classes instead
  
  *CAUTION* As stated in the Compatibility Rules, the HTML and CSS
  generated by SAPUI5 is not part of the public API and may change in
  patch and minor releases. If you decide to override styles, you have
  the obligation to test and update your modifications each time
  SAPUI5 is updated. A prerequisite for this is that you have control
  over the version of SAPUI5 being used, for example in a standalone
  scenario. This is not possible when running your app in the SAP
  Fiori launchpad where SAPUI5 is centrally loaded for all apps. As
  such, SAP Fiori launchpad apps should not override styles.

  /webapp/css/style.css
  #+BEGIN_SRC css
    .myAppDemoWT .myCustomButton.sapMBtn {
      margin-right: 0.125rem
    }

    html[dir="rtl"] .myAppDemoWT .myCustomButton.sapMBtn {
      margin-left: 0.125rem;
      margin-right: 0 
    }
    .myAppDemoWT .myCustomText {
      font-weight: bold;
    }
  #+END_SRC
  Create custom class combined with custom namespace class to ensure 
  styles are only applied to controls that are used within
  the app
  
* Nested Views
  Move the panel content to a separate view for better orgranization

  *Note* if the view is HelloPanel.view.js, then it is convention to
  have HelloPanel.controller.js
  
* Dialogs and Fragments
  *convention*
  - Always use the addDependent method to connect the dialog to the
    lifecycle management and data binding of the view, even though it
    is not added to its UI tree.
  - Private functions and variables should always start with an underscore.
  
  [[./dialog.png]]
  
  Fragments are light-weight UI parts (UI subtrees) which can be reused but 
  *do not have any controller*. They are good for situations in:
  - reusable UI across multiple views
  - exchange some parts of view under difference circumstance (e.g user roles, edit mode)
  - no additional controller logic is required

  Fragments consist of 1 to n controls. *At runtime*, fragments placed in a view
  behave similar to "normal" view content, meaning controls inside fragements will
  just be included into the view's DOM when rendered.

  *Dialogs* however are controls not designed to become part of a view.
  - open on top of reg. app content thus doesn't belong to specific view
  - thus, dialogs must be instantiated in the controller code
  
  Since this walkthrough wants to stick to declarative approach and create 
  reusable artiface to be as flexible as possible, and because dialogs cannot
  be specified as a view, an XML fragment will contain the dialog (since dialogs
  can be used in more than one view in the app)

  webapp/view/HelloPanel.view.xml
  #+BEGIN_SRC xml
      <mvc:View
       controllerName="sap.ui.demo.wt.controller.HelloPanel"
       xmlns="sap.m"
       xmlns:mvc="sap.ui.core.mvc">
       <Panel
          headerText="{i18n>helloPanelTitle}"
          class="sapUiResponsiveMargin"
          width="auto" >
          <content>
          <Button
             text="{i18n>openDialogButtonText}"
             press="onOpenDialog"
             class="sapUiSmallMarginEnd"/>

          <Button
             text="{i18n>showHelloButtonText}"
             press="onShowHello"
             class="myCustomButton"/>
          <Input
             value="{/recipient/name}"
             valueLiveUpdate="true"
             width="60%"/>
          <Text
             text="Hello {/recipient/name}"
             class="sapUiSmallMargin sapThemeHighlight-asColor myCustomText"/>
          </content>
       </Panel>
    </mvc:View>
  #+END_SRC
  
  Button simply calls an event handler function in the controller
  of the panel's content view

  webapp/view/HelloDialog.fragment.xml
  #+BEGIN_SRC xml
    <core:FragmentDefinition
       xmlns="sap.m"
       xmlns:core="sap.ui.core" >
       <Dialog
          id="helloDialog"
          title="Hello {/recipient/name}">
       </Dialog>
    </core:FragmentDefinition>
  #+END_SRC
  
  The fragment assetes are located in the core namespace, hence namespace
  for it inside the FragmentDefinition tag. Syntax is similar to view, but
  no 'controllerName' attribute  since fragments have no controllers. 

  *The fragment does not have any footprint in the DOM tree of the app, and*
  *there is no control instance of the fragment itself (only the contained controls).*
  *It (fragment) is simply a container for a set of reuse controls*

  'id' for 'Dialog' is added to access the dialog from HelloPanel controller

  webapp/controller/HelloPanel.controller.js
  #+BEGIN_SRC javascript
    sap.ui.define([
       "sap/ui/core/mvc/Controller",
       "sap/m/MessageToast"
    ], function (Controller, MessageToast) {
       "use strict";
       return Controller.extend("sap.ui.demo.wt.controller.HelloPanel", {
          onShowHello : function () {
             …
          },
          onOpenDialog : function () {
             var oView = this.getView();
             var oDialog = oView.byId("helloDialog");
             // create dialog lazily
             if (!oDialog) {
                // create dialog via fragment factory
                oDialog = sap.ui.xmlfragment(oView.getId(), "sap.ui.demo.wt.view.HelloDialog");
                oView.addDependent(oDialog);
             }

             oDialog.open();
          }

       });
    });
  #+END_SRC
  
  Note if fragment does not yet exists, it is instantiated via 'sap.ui.xmlfragment' method
  with the following arguments:
  - ID of HelloPanel view :: used to prefix the IDs inside the fragment. Since the
       ID 'helloDialog' for the Dialog control is defined, we can access *via the view* with 
       oView.byId("helloDialog")
  - Path of fragment definition :: sap.ui.demo.wt.view.HelloDialog

  The dialog is added as 'dependent' of the view to be connected to lifecycle of the view's
  model. A convient side-effect is the dialog will automatically destroyed when view
  is destroyed (else must manually destory dialog to free its resources).

  webapp/i18n/i18n.properties
  #+BEGIN_SRC sh
    # App Descriptor
    appTitle=Hello World
    appDescription=A simple walkthrough app that explains the most important concepts of OpenUI5

    # Hello Panel
    showHelloButtonText=Say Hello
    helloMsg=Hello {0}
    homePageTitle=Walkthrough
    helloPanelTitle=Hello World
    openDialogButtonText=Say Hello With Dialog
    dialogCloseButtonText=Ok
  #+END_SRC
  
  text bundle is extended by two new texts for open butten and dialog's close button.

* Fragment Callbacks
  User interaction to close the dialog box

  [[./fragmentcb.png]]

  webapp/controller/HelloPanel.controller.js
  #+BEGIN_SRC javascript
    sap.ui.define([
        "sap/ui/core/mvc/Controller",
        "sap/m/MessageToast"
    ], function (Controller, MessageToast) {
        "use strict";
     
        return Controller.extend("sap.ui.demo.wt.controller.HelloPanel", {
     
            onShowHello : function () {
                // read msg from i18n model
                var oBundle = this.getView().getModel("i18n").getResourceBundle();
                var sRecipient = this.getView().getModel().getProperty("/recipient/name");
                var sMsg = oBundle.getText("helloMsg", [sRecipient]);
     
                // show message
                MessageToast.show(sMsg);
            },
     
            onOpenDialog : function () {
                var oView = this.getView();
                var oDialog = oView.byId("helloDialog");
                // create dialog lazily
                if (!oDialog) {
                    // create dialog via fragment factory
                    oDialog = sap.ui.xmlfragment(oView.getId(), "sap.ui.demo.wt.view.HelloDialog", this);
                    // connect dialog to view (models, lifecycle)
                    oView.addDependent(oDialog);
                }
     
                oDialog.open();
            },
     
            onCloseDialog : function () {
                this.getView().byId("helloDialog").close();
            }

        });
     
    });
  #+END_SRC

  Notice how 'onCloseDialog' is an event fired by the fragment which is handled by this controller.
  Even though fragments do not have controllers, we passed 'this' as the third param of 'xmlfragment'
  method thus associating the controller to the fragment during instantiation. Furthermore, from
  passing 'oView.getId()', we are able to get fragment via view.

  *note* third parameter of xmlfragment need not necessarily have to be a controller but any object.

  webapp/view/HelloDialog.fragment.xml
  #+BEGIN_SRC xml
    <core:FragmentDefinition
       xmlns="sap.m"
       xmlns:core="sap.ui.core" >
       <Dialog
          id="helloDialog"
          title ="Hello {/recipient/name}">
          <beginButton>
             <Button
                text="{i18n>dialogCloseButtonText}"
                press="onCloseDialog"/>
          </beginButton>
       </Dialog>
    </core:FragmentDefinition>
  #+END_SRC

  Add button to the beginButton aggregation. There is also endButton aggregation. beginButton 
  is always placed before the endButton  on the UI.
* Icons
  *conventions*
  - Always use icon fonts rather than images wherever possible, as
    they are scalable without quality loss (vector graphics) and do
    not need to be loaded separately.
  
  [[./icons.png]]

    
  #+BEGIN_SRC xml
      <mvc:View
       controllerName="sap.ui.demo.wt.controller.HelloPanel"
       xmlns="sap.m"
       xmlns:mvc="sap.ui.core.mvc">
       <Panel
          headerText="{i18n>helloPanelTitle}"
          class="sapUiResponsiveMargin"
          width="auto" >
          <content>
             <Button
                icon="sap-icon://world"
                 text="{i18n>openDialogButtonText}"
                press="onOpenDialog"
                class="sapUiSmallMarginEnd"/>
             <Button
                text="{i18n>showHelloButtonText}"
                press="onShowHello"
                class="myCustomButton"/>
             <Input
                value="{/recipient/name}"
                valueLiveUpdate="true"
                width="60%"/>
               <Text
                  text="Hello {/recipient/name}"
                  class="sapUiSmallMargin sapThemeHighlight-asColor myCustomText"/>
          </content>
       </Panel>
    </mvc:View>
  #+END_SRC

  The sap-icon:// protocol is indicating that an icon from the icon font should be loaded
  
  webapp/view/HelloDialog.fragment.xml
  #+BEGIN_SRC xml
      <core:FragmentDefinition
       xmlns="sap.m"
       xmlns:core="sap.ui.core" >
       <Dialog
          id="helloDialog"
          title ="Hello {/recipient/name}">
          <content>
             <core:Icon
                src="sap-icon://hello-world"
                size="8rem"
                class="sapUiMediumMargin"/>
          </content>
          <beginButton>
             <Button
                text="{i18n>dialogCloseButtonText}"
                press="onCloseDialog"/>
          </beginButton>
       </Dialog>
    </core:FragmentDefinition>
  #+END_SRC

  Add icon control to content aggregation of dialog. Also define size and medium margin on it
* Reuse of fragments (e.g Dialog)
  *conventions*
  - Put all assets used across multiple controllers in separate modules
  
  demonstation of reusing fragment across views or whole app.

  note previously:
  - fragment events were handled by HelloPanel controller
  - this makes fragment less flexable since tied to controller...
  - hence cause for undesired code redundancy

  solution:
  - expand reuse concept and invoke dialog at component level!
  - thus dialog will be opened by component

  webapp/Component.js
  #+BEGIN_SRC javascript
     sap.ui.define([
        "sap/ui/core/UIComponent",
        "sap/ui/model/json/JSONModel",
        "sap/ui/demo/wt/controller/HelloDialog" // new

    ], function (UIComponent, JSONModel, HelloDialog) {
        "use strict";
        return UIComponent.extend("sap.ui.demo.wt.Component", {
            metadata : {
                manifest : "json"
            },
            init : function () {
                // call the init function of the parent
                UIComponent.prototype.init.apply(this, arguments);
                // set data model
                var oData = {
                    recipient : {
                        name : "World"
                    }
                };
                var oModel = new JSONModel(oData);
                this.setModel(oModel);

                // set dialog
                this._helloDialog = new HelloDialog(this.getRootControl()); // new
            },

            openHelloDialog : function () {
                this._helloDialog.open();
            }
        });
    });
  #+END_SRC

  dialog instantiation is refactored to new helper object which is stored in a private
  property of the component. The instantiation of helper object is passed the view
  instance to which the dialog is added (see HelloDialog.js below)

  To connect the reuse dialog to lifecycle of route view of the app, we pass
  an instance of the root view on to the constructor (via getRootControl). This will
  prefix the dialog's ID with ID of root view to avoid name collisions.

  *note* As defined in parameter rootView in the manifest.json file,
  our root view is sap.ui.demo.wt.view.App. From the component, the
  root view can be retrieved at runtime by accessing the rootControl
  aggregation.

  To allow opening of dialog from other controllers as well, we implement a 
  reuse function openHelloDialog which called the open method of the helper
  object. By doing so, we decouple the implementation details of the reuse
  dialog from the application coding.

  webapp/controller/HelloDialog.js
  #+BEGIN_SRC javascript
    sap.ui.define([
        "sap/ui/base/Object"
    ], function (UI5Object) {
        "use strict";

        return UI5Object.extend("sap.ui.demo.wt.controller.HelloDialog", {

            constructor : function (oView) {
                this._oView = oView;    
            },


            open : function () {
                var oView = this._oView;
                var oDialog = oView.byId("helloDialog");
                
                // create dialog lazily
                if (!oDialog) {
                    var oFragmentController = {
                        onCloseDialog : function () {
                            oDialog.close();
                        }
                    };
                    // create dialog via fragment factory
                    oDialog = sap.ui.xmlfragment(oView.getId(), 
                                                 "sap.ui.demo.wt.view.HelloDialog", 
                                                 oFragmentController);
                    // connect dialog to the root view of this component (models, lifecycle)
                    oView.addDependent(oDialog);
                }
                oDialog.open();
            }
        });

    });
  #+END_SRC

  HelloDialog reuse object extends the base object to inherit core functionality of OpenUI5.
  Note a local helper object, rather than controller is passed to xmlfragment as the third
  parameter to handle 'onCloseDialog' event.
  
  When the view is being destroyed, we must remove the dialog from the dependent
  aggregation of the view. Otherwise, the reuse dialog would be automatically destroyed.
  We want the reuse dialog to be destroyed when whole application component is being 
  dstroyed. 

  -> in the 'exit' lifecycle method of SAPUI5 that is called when a component is being
  destroyed, we destroy the internal dialog instance if it has been created. Thus, the
  lifecycle of the dialog is properly connected to application's lifecycle.

  The open method contains the dialog's instantiation. oView is used to connect
  the current view to the dialog, and the open method of this object is later called
  in the controller.
  
  webapp/controller/HelloPanel.controller.js
  #+BEGIN_SRC javascript
      sap.ui.define([
        "sap/ui/core/mvc/Controller",
        "sap/m/MessageToast"
    ], function (Controller, MessageToast) {
        "use strict";
        return Controller.extend("sap.ui.demo.wt.controller.HelloPanel", {
            onShowHello : function () {
                // read msg from i18n model
                var oBundle = this.getView().getModel("i18n").getResourceBundle();
                var sRecipient = this.getView().getModel().getProperty("/recipient/name");
                var sMsg = oBundle.getText("helloMsg", [sRecipient]);
                // show message
                MessageToast.show(sMsg);
            },
            onOpenDialog : function () {
                this.getOwnerComponent().openHelloDialog();
            }
        });
    });
  #+END_SRC
  
  onOpenDialog method accesses its component via getOwnerComponent

  webapp/view/App.view.xml
  #+BEGIN_SRC xml
      <mvc:View
        controllerName="sap.ui.demo.wt.controller.App"
        xmlns="sap.m"
        xmlns:mvc="sap.ui.core.mvc"
        displayBlock="true">
        <App class="myAppDemoWT">
            <pages>
                <Page title="{i18n>homePageTitle}">
                    <headerContent>
                        <Button
                            icon="sap-icon://hello-world"
                            press="onOpenDialog"/>
                    </headerContent>
                    <content>
                        <mvc:XMLView viewName="sap.ui.demo.wt.view.HelloPanel"/>
                    </content>
                </Page>
            </pages>
        </App>
    </mvc:View>
  #+END_SRC
  
  Add button to header area of the app view to show the reuse of hello world dialog.
  When pressing, the buttong will open a dialog as with the button previously
  created in the panel.
  
  webapp/controller/App.controller.js
  #+BEGIN_SRC javascript
    ap.ui.define([
        "sap/ui/core/mvc/Controller"
    ], function (Controller) {
        "use strict";

        return Controller.extend("sap.ui.demo.wt.controller.App", {

            onOpenDialog : function () {
                this.getOwnerComponent().openHelloDialog();
            }
        });

    });
  #+END_SRC

  We add the method 'onOpenDialog' also to the app controller so that the dialog will
  open with a reference to the current view.
* Aggregation Binding
  We will display invoice data in JSON format to be displayed in a panel
  
  [[./aggbinding.png]]

  webapp/Invoices.json
  #+BEGIN_SRC js
      {
      "Invoices": [
        {
          "ProductName": "Pineapple",
          "Quantity": 21,
          "ExtendedPrice": 87.2000,
          "ShipperName": "Fun Inc.",
          "ShippedDate": "2015-04-01T00:00:00",
          "Status": "A"
        },
        {
          "ProductName": "Milk",
          "Quantity": 4,
          "ExtendedPrice": 9.99999,
          "ShipperName": "ACME",
          "ShippedDate": "2015-02-18T00:00:00",
          "Status": "B"
        },
        {
          "ProductName": "Canned Beans",
          "Quantity": 3,
          "ExtendedPrice": 6.85000,
          "ShipperName": "ACME",
          "ShippedDate": "2015-03-02T00:00:00",
          "Status": "B"
        },
        {
          "ProductName": "Salad",
          "Quantity": 2,
          "ExtendedPrice": 8.8000,
          "ShipperName": "ACME",
          "ShippedDate": "2015-04-12T00:00:00",
          "Status": "C"
        },
        {
          "ProductName": "Bread",
          "Quantity": 1,
          "ExtendedPrice": 2.71212,
          "ShipperName": "Fun Inc.",
          "ShippedDate": "2015-01-27T00:00:00",
          "Status": "A"
        }
      ]
    }
  #+END_SRC

  #+BEGIN_SRC js
      {
      …
      "sap.ui5": {
        "_version": "1.1.0",
        "rootView": "sap.ui.demo.wt.view.App",

        "dependencies": {
          "minUI5Version": "1.30",
          "libs": {
            "sap.m": {}
          }
        },
        "models": {
          "i18n": {
            "type": "sap.ui.model.resource.ResourceModel",
            "settings": {
              "bundleName": "sap.ui.demo.wt.i18n.i18n"
            }
          },
          "invoice": {
            "type": "sap.ui.model.json.JSONModel",
            "uri": "Invoices.json"
          }
        }
      }
    }
  #+END_SRC

  We add model 'invoice' to the manifest.json. We set the type since 
  we want a JSONModel. With this config, the component will automatically
  instantiate a new JSONModel which loads the invoice data from
  Invoices.json file. The instantiated model is named 'invoice' and 
  the named model will be visible throughout the app.

  webapp/view/App.view.xml
  #+BEGIN_SRC xml
      <mvc:View
       controllerName="sap.ui.demo.wt.controller.App"
       xmlns="sap.m"
       xmlns:mvc="sap.ui.core.mvc"
       displayBlock="true" >
       <App class="myAppDemoWT">
          <pages>
             <Page title="{i18n>homePageTitle}">
                <headerContent>
                   <Button
                      icon="sap-icon://hello-world"
                      press="onOpenDialog"/>
                </headerContent>
                <content>
                   <mvc:XMLView viewName="sap.ui.demo.wt.view.HelloPanel"/>
                   <mvc:XMLView viewName="sap.ui.demo.wt.view.InvoiceList"/>
                </content>
             </Page>
          </pages>
       </App>
    </mvc:View>
  #+END_SRC
  
  A second view is added to the content aggregation

  #+BEGIN_SRC xml
    <mvc:View
       xmlns="sap.m"
       xmlns:mvc="sap.ui.core.mvc">
       <List
          headerText="{i18n>invoiceListTitle}"
          class="sapUiResponsiveMargin"
          width="auto"
          items="{invoice>/Invoices}" >
          <items>
             <ObjectListItem
                title="{invoice>Quantity} x {invoice>ProductName}"/>
          </items>
       </List>
    </mvc:View>
  #+END_SRC

  the list control defines a custom header test. The items aggregation of
  the list is bound to the root path of Invoices.json. 

  Since we defined a named model via manifest.json, we must prefix each
  binding definition with the identifier 'invoice'

  In the 'items' aggregation, we define the template for the list that'll
  be automatically repeated for each invoice of the test data. More
  precisely, we use an ObjectListItem to create a control for each
  aggregated child of the items aggregation. This is achieved by defining
  a relative path  (without / in the beginning) and works because we have
  bound the items aggregation via *items={invoice/Invoices}* to invoices.
  
* Data Types
  *conventions*
  - use data types instead of custom formatters whenever possible
  
  SAPUI5 data types to format price with a locale-dependent decimal separator and
  two digits after the separator

  
  webapp/view/InvoiceList.view.xml
  #+BEGIN_SRC xml
    <mvc:View
       controllerName="sap.ui.demo.wt.controller.InvoiceList"
       xmlns="sap.m"
       xmlns:mvc="sap.ui.core.mvc">
       <List
          headerText="{i18n>invoiceListTitle}"
          class="sapUiResponsiveMargin"
          width="auto"
          items="{invoice>/Invoices}">
          <items>
             <ObjectListItem
            title="{invoice>Quantity} x {invoice>ProductName}"
            number="{
                parts: [{path: 'invoice>ExtendedPrice'}, {path: 'view>/currency'}],
                type: 'sap.ui.model.type.Currency',
                formatOptions: {
                    showMeasure: false
                }
            }"
            numberUnit="{view>/currency}"/>
        </items>
       </List>
    </mvc:View>
  #+END_SRC

  *footnote* property and attribute are used interchangeably in these notes

  We apply the currency data type on the number attribute by setting the type
  attribute of the binding syntax to sap.ui.model.type.Currency

  The special binding syntax of the number attribute is call "Calculated fields", 
  allowing binding of multiple properties from different models to a single 
  property of a control. Properties bound from different models are called
  "parts".

  In the example above, the property of the ObjectListItem control is number and
  the bound properties (parts) are retrieved from two different models 'invoice'
  and 'view'

  We add controller for InvoiceList and use currency property as second part
  of the binding syntax. The sap.ui.model.type.Currency type will handle 
  formatting of the price.

  Also, the formatting option 'showMeasure' is set to false to hide the currency
  code in the property 'number' since it is passed to ObjectListItem control as
  a seprate property 'numberUnit'

  /webapp/controller/InvoiceList.controller.js
  #+BEGIN_SRC js
      sap.ui.define([
        "sap/ui/core/mvc/Controller",
        "sap/ui/model/json/JSONModel"
    ], function (Controller, JSONModel) {
        "use strict";

        return Controller.extend("sap.ui.demo.wt.controller.InvoiceList", {

            onInit : function () {
                var oViewModel = new JSONModel({
                    currency: "EUR"
                });
                this.getView().setModel(oViewModel, "view");
            }

        });
    });
  #+END_SRC
  
  Since currency code is not part of the data model, we degine a view model 
  in the controller of invoice list to bind to the formatter of the
  number field. 

  View models can hold any configuration options assigned to a control
  to bind properties such as visibility.
* Expression Binding
  *conventions*
  - Only use expressio binding for trivial calculations
  
  Sometimes the predefined types of SAPUI5 are not flexiable enough.
  Expressions allow for cutom calculation of formatting of the view.
  
  webapp/view/InvoiceList.xml
  #+BEGIN_SRC xml
    <mvc:View
    controllerName="sap.ui.demo.wt.controller.InvoiceList"
    xmlns="sap.m"
       xmlns:mvc="sap.ui.core.mvc">
       <List
          headerText="{i18n>invoiceListTitle}"
          class="sapUiResponsiveMargin"
          width="auto"
          items="{invoice>/Invoices}" >
          <items>
             <ObjectListItem
                title="{invoice>Quantity} x {invoice>ProductName}"
                number="{
            parts: [{path: 'invoice>ExtendedPrice'}, {path: 'view>/currency'}],
            type: 'sap.ui.model.type.Currency',
            formatOptions: {
                showMeasure: false
            }
            }"
            numberUnit="{view>/currency}"
            numberState="{= ${invoice>ExtendedPrice} > 50 ? 'Error' : 'Success' }"/>
          </items>
       </List>
    </mvc:View>
  #+END_SRC

  The numberState property added to the declarative view introduces the syntax starting
  with the symbol =. = is called an expression and can be used for calculation logic 
  such as ternary operator.

  A model binding inside an expression binding has to be escaped with $. 

  Expressions are limited to a particular set of operations that help formatting the data
* Custom Formatters
  Custom formatting function for more complex logic for formatting properties
  of the data model.

  webapp/model/formatter.js
  #+BEGIN_SRC js
      sap.ui.define([], function () {
        "use strict";
        return {
            statusText: function (sStatus) {
                var resourceBundle = this.getView().getModel("i18n").getResourceBundle();
                switch (sStatus) {
                    case "A":
                        return resourceBundle.getText("invoiceStatusA");
                    case "B":
                        return resourceBundle.getText("invoiceStatusB");
                    case "C":
                        return resourceBundle.getText("invoiceStatusC");
                    default:
                        return sStatus;
                }
            }
        };
    });
  #+END_SRC

  We place formatter file in model folder since formatterrs work on data properties
  and format them for display on the UI. We also move Invoices.json file to the model.

  This time, no need to extend any base object byut just return a JS object with 
  the formatter functions inside the sap.ui.define call.

  statusText function returns human readable text from the resourceBundle

  webapp/controller/InvoiceList.controller.js
  #+BEGIN_SRC js
      sap.ui.define([
        "sap/ui/core/mvc/Controller",
        "sap/ui/model/json/JSONModel",
        "sap/ui/demo/wt/model/formatter"
    ], function (Controller, JSONModel, formatter) {
        "use strict";
        return Controller.extend("sap.ui.demo.wt.controller.InvoiceList", {
            formatter: formatter,
            onInit : function () {
                var oViewModel = new JSONModel({
                    currency: "EUR"
                });
                this.getView().setModel(oViewModel, "view");
            }
        });
    });
  #+END_SRC

  formatter functions are loaded to the InvoiceList.controller.js. Dependency
  is added to our custom formatter module. This controller simply stores the loaded
  formatter functions in the local property formatter to be able to access them in
  the view.

  webapp/view/InvoiceList.view.xml
  #+BEGIN_SRC xml
      <mvc:View
        controllerName="sap.ui.demo.wt.controller.InvoiceList"
        xmlns="sap.m"
        xmlns:mvc="sap.ui.core.mvc">
        <List
            headerText="{i18n>invoiceListTitle}"
            class="sapUiResponsiveMargin"
            width="auto"
            items="{invoice>/Invoices}">
            <items>
                <ObjectListItem
                    title="{invoice>Quantity} x {invoice>ProductName}"
                    number="{
                        parts: [{path: 'invoice>ExtendedPrice'}, {path: 'view>/currency'}],
                        type: 'sap.ui.model.type.Currency',
                        formatOptions: {
                            showMeasure: false
                        }
                    }"
                    numberUnit="{view>/currency}"
                    numberState="{= ${invoice>ExtendedPrice} > 50 ? 'Error' : 'Success' }">
                    <firstStatus>
                        <ObjectStatus text="{
                            path: 'invoice>Status',
                            formatter: '.formatter.statusText'
                        }"/>
                    </firstStatus>
                </ObjectListItem>

            </items>
        </List>
    </mvc:View>
  #+END_SRC

  firstStatus aggregation is added to ObjectListItem control that'll display the invoice status.
  Custom formatter function is specified with the reservered property 'formatter' 
  binding syntax. The "." in the formatter means the function is looked up in the controller
  of the current view. Since the property formatter is defined in the controller, it
  can be accessed by '.formatter.statusText'.

  
* Filtering and searching
  - search field to define a filter that only shows items
    matching the term

    [[./filtering.png]]

  webapp/view/InvoiceList.view.xml
  #+BEGIN_SRC xml
      <mvc:View
       controllerName="sap.ui.demo.wt.controller.InvoiceList"
       xmlns="sap.m"
       xmlns:mvc="sap.ui.core.mvc">
       <List
          id="invoiceList"
          class="sapUiResponsiveMargin"
          width="auto"
          items="{invoice>/Invoices}" >
          <headerToolbar>
             <Toolbar>
                <Title text="{i18n>invoiceListTitle}"/>
                <ToolbarSpacer/>
                <SearchField width="50%" search="onFilterInvoices" selectOnFocus="false"/>
             </Toolbar>
          </headerToolbar>
          <items>
             <ObjectListItem>
            …
             </ObjectListItem/>
          </items>
       </List>
    </mvc:View>
  #+END_SRC

  extend the view by adding a search control that we add to list of invoices.
  notes:
  - since search field is part of list header, each change on the list binding
    will trigger rerendering of the while list, including the search field.
  - selectOnFocus=false ensures cursor statys at the same position.

  headerToolbar aggregation replaces title property. A toolbar control is way more
  flexible. sap.m.Title control on the left, sap.m.SearchField on the right with
  a sap.m.ToolbarSpacer in between.
  
  webapp/controller/InvoiceList.controller.js
  #+BEGIN_SRC js
      sap.ui.define([
        "sap/ui/core/mvc/Controller",
        "sap/ui/model/json/JSONModel",
        "sap/ui/demo/wt/model/formatter",
        "sap/ui/model/Filter",
        "sap/ui/model/FilterOperator"
    ], function (Controller, JSONModel, formatter, Filter, FilterOperator) {
        "use strict";
        return Controller.extend("sap.ui.demo.wt.controller.InvoiceList", {
            formatter: formatter, 
            onInit : function () {
                var oViewModel = new JSONModel({
                    currency: "EUR"
                });
                this.getView().setModel(oViewModel, "view");
            },
            onFilterInvoices : function (oEvent) {

                // build filter array
                var aFilter = [];
                var sQuery = oEvent.getParameter("query");
                if (sQuery) {
                    aFilter.push(new Filter("ProductName", FilterOperator.Contains, sQuery));
                }

                // filter binding
                var oList = this.getView().byId("invoiceList");
                var oBinding = oList.getBinding("items");
                oBinding.filter(aFilter);
            }
        });
    });
  #+END_SRC

  #+RESULTS:

  Two new dependencies introduced for filtering. 
  Filter - holds the configuration for the filter action
  FilterOperator - helper type needed to specify filter

  Event handlers always reveice an event argument than can be
  used to acceess the parameters the event provides. In this case,
  search field defines a parameter 'query' we can access via 
  getParameter("query")

  If query not empty, add filter object to the empty array of filters.
  This makes sure we see all list elements again. By adding more filters
  to this array we can search by more than one data filter. This this example,
  we search ProductName path and specify a filter operator that will search for
  the given query string.

  The list is access with the ID specified in the view since the control
  is automatically prefixed (namespaced) by the view ID (hence byId 
  helper function)

  On the list control, we access the binding of the aggregation 'items'
  to filter it with our newly constructed filter object. 

  *note* FilterOperator.Contains is not case-sensitive
  
